
=== Quantities

ASysC also manages the sizes for better readability. The quantities supported are:

[cols="1,14"]
|===
|Quantity | Description

|p     | pico
|n     | nano
|u     | micro
|m     | milli
|k or K| kilo
|M     | mega
|G     | giga
|===

So if you write *1G* for example, it will correspond to the value *1000000000*.

== Instantiation of a component

A component instantiation is written in the following form:

    <Instance name>. <Component name>( <node list>, <parameter list>)

For example, for a resistance of type *CR* of name *R1*, value *1K* the instantiation will be written as follows:
    
    R1.CR( @3, @4, 1K)

== Frequency and time analysis

If you are looking forward to see what ASysC is capable of and want to pause before continuing the article, you can run all the examples with the following command typed in the root directory:

    make run

This command will start the simulation of all the examples contained in the project and display the results.
Now that you have been able to appreciate the performance of ASysC let’s go into detail about the different analyses supported.

=== Frequency analysis

Let’s start with the simulation of our first circuit and begin in a first step by a frequency analysis of the circuit (so-called «AC» analysis). The transformation of the system of equations to perform a frequency analysis is done by calling the *SOLVE_AC()* function:

    CIRCUIT:= SOLVE_AC( RLC )

This function will start the system resolution by preapplying the Laplace transform. The converted circuit is then used for frequency analysis. It is called «CIRCUIT» because it is the default variable used by ASysC to recognize the circuit that will be converted into a Python model.

NOTE: the bias point calculation is not yet implemented in the current version of ASysC.

==== Example with a conventional circuit R, L, C

Let's return to our initial example. Our circuit comprises four components: a voltage source CV, a resistor CR, an inductor CL, a capacitor CC, whose names are V, R, L and C respectively. Some component names are preceded by the letter 'C' to avoid conflicts with instance names. Nodes are identified as @1, @2, @3 and @4.

[.text-center]
image::RLC_ac.png[]

The netlist description of this circuit is as follows:

----
    `include <components.rule>

    RLC() := {
        V.CV(@1, @2, 1);
        R.CR(@2, @3, 100);
        L.CL(@3, @4, 1m);
        C.CC(@4, @1, 10u)
    };

    CIRCUIT := SOLVE_AC( RLC )
----

Components are declared in a list assigned to the RLC() rule, which is then given as a parameter to function SOLVE_AC().

The `include directive is used to include the definitions of components that are not included by default, unlike the basic rules. It is entirely possible to write your own component library and include it in your project.

=== Generating Python code

Having seen how to declare a circuit and instantiate components, let's move on to the most interesting part: generating a Python model of our circuit. For this step, we'll use the following command:

    cd examples/
    ../lightcas/bin/asysc -i ac/RLC/RLC.cir -o ac/RLC/RLC.py -t ac

This command generates the circuit model in Python, as shown below:

----
    def compute_t(self):
            self._setf(self.C_U, -(1/((0.001*self.s+1)+1e-08*self.s**2)), self.freq)
            self._setf(self.V_I, -((1e-05*self.s)/((0.001*self.s+1)+1e-08*self.s**2)), self.freq)
            self._setf(self.V_U, ((1e-08*self.s**2+0.001*self.s)+1)/((1e-08*self.s**2+0.001*self.s)+1), self.freq)
            self._setf(self.R_U, -((0.001*self.s)/((0.001*self.s+1)+1e-08*self.s**2)), self.freq)
            self._setf(self.R_I, -((1e-05*self.s)/((0.001*self.s+1e-08*self.s**2)+1)), self.freq)
            self._setf(self.L_U, -((1e-08*self.s**2)/((1e-08*self.s**2+1)+0.001*self.s)), self.freq)
            self._setf(self.L_I, -((1e-05*self.s)/((1+1e-08*self.s**2)+0.001*self.s)), self.freq)
            self._setf(self.C_I, -((1e-05*self.s)/((0.001*self.s+1)+1e-08*self.s**2)), self.freq)
----

This extract shows the classic transfer functions of an RLC circuit.
To run the frequency simulation from the Python code, create the circuit object in the simulation.py file and call the simulate_f function with the start frequency, end frequency and desired number of samples as parameters:

    my_circuit = circuit()
    my_circuit.simulate_f(10, 1e6, 100)    

Once the simulation has been run, all that remains is to display the data contained in NumPy arrays.
For our example, the simulation is launched with the command :

    cd ac/RLC/
    python3 simulation.py

And if all goes well, you'll see the result displayed graphically.

[.text-center]
image::RLC_ac.png[]

=== Frequency analysis with dynamic change of parameter values

In some cases, it may be useful to be able to dynamically change the value of certain parameters during the various simulation runs, in order to avoid recompiling the circuit in the event of a component value change. To do this, we use the _getv() function which, during simulation, calls the Python function of the same name, capable of fetching the current value of the variable given as a parameter. The modified circuit looks like this:

----
    `include <components.rule>

    RLC( PR, PL, PC ) := {
        V.CV (@1, @2, 1);
        R1.CR(@2, @3, PR );
        L1.CL(@3, @4, PL );
        C1.CC(@4, @1, PC )
    };

    CIRCUIT := SOLVE_AC( RLC( _getv( R ), _getv( L ), _getv( C ) ) )
----

The RLC() circuit now admits three parameters PR, PL and PC, whose values will take the values of the Python variables self.R, self.L and self.C through the _getv() function during simulation.

The user can then dynamically change the values of the R, L and C components using the “slider” functionality available in the MathplotLib library. For more information, please refer to the “RLC_slider” Python example code.

RLC circuit, frequency analysis and dynamic setting of component values using MathPlotlib sliders.

[.text-center]
image::ac_slider.png[]

=== Another circuit example in frequency analysis: simulation of a Sallen-Key filter. 
In the example below, we simulate a second-order Sallen-Key filter [9] consisting of two RC cells and an operational amplifier. The simulation displays gain and phase diagrams as a function of frequency.

[.text-center]
image::sallen_key_circuit.png[]

== Time analysis (Transient)
Transforming the system of equations to perform a transient analysis is done in the same way as above, but with a call to function SOLVE_TRANS():

    CIRCUIT := SOLVE_TRANS( RLC ) )

This directive solves the system by first performing all the necessary transformations on the non-linear and reactive elements. As previously stated, the transformed circuit must always bear the name “CIRCUIT”. This is the variable used by ASysC to convert the circuit into a Python model.
There are several methods for solving a non-linear system. The simplest is the Newton-Raphson method [10], also known as the “tangent” method. It involves replacing the system's non-linear functions with their tangents, calculated at the iteration point. Once the tangents have been calculated, the system solved and the unknowns determined, the tangents are recalculated at the new iteration point and the process repeated. The problem thus comes down to solving a sequence of linear systems whose solutions converge on the real solution.  
For the simulation of reactive elements, the trapezoidal integration algorithm is used. This gives good results without being too complex to implement.

=== Example of a Graetz bridge simulation in transient analysis

In this example, the circuit consists of a sinusoidal source V, a source resistor R2, four diodes (D1, D2, D3 and D4) and a load represented by a resistor R1 and a capacitor C.
The circuit description is as follows:

----
    `include <components.rule>

    graetz_bridge( RS ) :=
    {
        V.VSIN ( @5, @3, 10, 2*PI*600 );
        R2.CR ( @5, @2, 1 );
        D1.DIODE( @1, @2 );
        D2.DIODE( @1, @3 );
        D3.DIODE( @2, @4 );
        D4.DIODE( @3, @4 );
        R1.CR ( @4, @1, RS );
        C.CC ( @1, @4, 1u )
    };

    CIRCUIT := SOLVE_TRANS( graetz_bridge( 500 ) )
----

This corresponds to the following diagram and simulation result:

[.text-center]
image::graetz_bridge.png[]

In the same way as for the frequency simulation, the time simulation is launched in the Python code by creating the circuit object in the simulation.py file and calling the simulate_t() function.  This function receives as parameters the simulation time, the number of samples, the desired resolution and the maximum number of iterations for the nonlinear convergence algorithm.

my_circuit = circuit()
my_circuit.simulate_t(1e-6, 500, 0.1, 50)

In some cases, it may be necessary to initialize certain variables before simulation. In this case, use the init() function applied to the element object containing the variable, as in the transient/oscillator example:

    my_circuit.NOT1_Uin.init( 5 )

== Compact modeling
Let's take as an example the NE555, a relatively complex component. Rather than modeling its behavior with all its transistors, which would entail an extremely long simulation, we prefer to use a more compact behavioral description consisting of just a few equations. This is known as “compact modeling”. The NE555's compact behavioral description contains just two subcomponents: a SWITCH switch and an SRFFC set-reset flip-flop, plus a few logic equations. It all fits into just a few lines, as illustrated below:

----
    NAME.NE555( @trigger, @threshold, @discharge, @output, @vcc, @gnd ) :=
    {
        NAME.VCC = ACROSS( @vcc, @gnd );
        NAME.UTRIG = ACROSS( @trigger, @gnd );
        NAME.UTRESH = ACROSS( @threshold, @gnd );
        NAME.UOUT = ACROSS( @output, @gnd );
        NAME.UIN1 = ACROSS( NAME.@in1, @gnd );
        NAME.UIN2 = ACROSS( NAME.@in2, @gnd );  
        
        NAME.UIN1 = ( NAME.UTRIG < ( NAME.VCC / 3 ) );
        NAME.UIN2 = ( NAME.UTRESH < ( NAME.VCC * 2 / 3 ) );

        NAME.SW.SWITCH( @discharge, @gnd, NAME.UOUT < (NAME.VCC/2) );
        NAME.SR.SRFFC( NAME.@in1, NAME.@in2, @output, @vcc, @gnd)
    };
----

Note that the compact model contains “sub-nodes”: NAME.@in1 and NAME.@in2. As our NE555 instance is called U, once instantiated, these two nodes will be called U.@in1 and U.@in2 respectively, and will not conflict with nodes external to the component.
Below is a simulation of the NE555 in an oscillator configuration:

[.text-center]
image::ne555.png[]

This example shows that a compact behavioral description of a component allows you to obtain a simulation result close to a real description, while reducing computation time.
Note that the circuit shown in the example above contains so-called “probes”. These are used to visualize the voltages between two given nodes. The first is called P1 and is connected to the NE555's OUT output and ground. The second is called P2 and is connected to the NE555's DISH input and ground. The use of these “probes” is extremely practical, as they allow access to all the voltages in the circuit.

